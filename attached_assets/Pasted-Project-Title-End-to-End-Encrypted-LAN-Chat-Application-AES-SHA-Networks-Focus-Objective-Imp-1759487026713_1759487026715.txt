Project Title: End-to-End Encrypted LAN Chat Application (AES + SHA, Networks Focus)

Objective:
Implement a simple end-to-end encrypted chat application that works over a local network using TCP sockets in Python. The application must demonstrate core networking concepts (client-server model, sockets, threading, message framing) and basic cryptography (AES encryption, SHA-256 hashing for key derivation).

ðŸ”¹ Architecture

Server

Built with Python socket and threading.

Listens for client connections.

Stores connected clients.

Forwards encrypted messages between clients (server never decrypts).

Relays ciphertext only.

Client

Built with Python socket + either terminal-based UI or Tkinter GUI.

Connects to server, provides username.

Before sending, encrypts plaintext message using AES.

Decrypts received ciphertext messages.

Shared key derived from a common password using SHA-256.

Crypto Module (crypto.py)

Provides:

get_key(password) â†’ 256-bit AES key from password via SHA-256.

encrypt(message, key) â†’ returns nonce + tag + ciphertext.

decrypt(cipher_bytes, key) â†’ verifies and returns plaintext.

Uses AES in EAX mode (provides confidentiality + integrity).

UI (optional but basic)

Terminal: input field for message, print chat history.

Or Tkinter: simple text area + entry field.

ðŸ”¹ Features

Multi-client chat (multiple users can connect).

Usernames included in messages.

Messages end-to-end encrypted with AES.

Shared key derived from password (hashed via SHA-256).

Server is a dumb relay (cannot read plaintext).

Message framing (prefix length before ciphertext).

Wireshark shows ciphertext packets, proving encryption.

ðŸ”¹ Tasks (Step-by-Step)

Setup Project Structure

/chat-project
  server.py
  client.py
  crypto.py
  ui.py (optional, Tkinter)
  README.md


Plain TCP Chat (no encryption)

Implement threaded server to accept multiple clients.

Implement client that sends/receives plaintext messages.

Add AES + SHA Crypto

Implement crypto.py with AES (EAX mode) + SHA-256 key derivation.

Test encrypt/decrypt separately.

Integrate Encryption

Client encrypts all outgoing messages.

Server forwards ciphertext blindly.

Client decrypts incoming messages.

Usernames & Metadata

Each client provides a username.

Encrypted message format: [username] message.

Include timestamp.

Message Framing

Prefix each message with its length to handle variable sizes.

Basic UI

Terminal-based chat (loop with input() + message printing).

Optional Tkinter GUI (text area for messages + entry field).

Testing

Run multiple clients on LAN.

Capture traffic in Wireshark â†’ verify only ciphertext visible.

Documentation

Write README:

How to run server & client.

How encryption works.

Demo steps with Wireshark.

ðŸ”¹ Deliverables

Code files: server.py, client.py, crypto.py, ui.py

README.md with:

Architecture diagram.

Setup instructions.

Demo steps.

Limitations (shared key, no forward secrecy).

âš¡ This prompt ensures whoever implements it will:

Cover all networking concepts (sockets, threading, message relay).

Show encryption in action (AES + SHA).

Produce a student-level E2EE chat app with a clear LAN focus.